{"version":3,"file":null,"sources":["src/utils/if-undefined.js","src/utils/utils-consts.js","src/utils/prefixed.js","src/touchactionjs/get-touchaction-props.js","src/touchactionjs/touchaction-Consts.js","src/inputjs/input-consts.js","src/recognizerjs/recognizer-consts.js","src/utils/assign.js","src/utils/unique-id.js","src/utils/each.js","src/utils/invoke-array-arg.js","src/utils/in-array.js","src/utils/bool-or-fn.js","src/recognizerjs/get-recognizer-by-name-if-manager.js","src/recognizerjs/state-str.js","src/recognizerjs/recognizer-constructor.js","src/recognizers/attribute.js","src/recognizers/rotate.js","src/recognizers/pinch.js","src/recognizerjs/direction-str.js","src/recognizers/pan.js","src/recognizers/swipe.js","src/utils/bind-fn.js","src/utils/set-timeout-context.js","src/inputjs/get-distance.js","src/recognizers/tap.js","src/recognizers/press.js","src/utils/in-str.js","src/touchactionjs/clean-touch-actions.js","src/touchactionjs/touchaction-constructor.js","src/utils/has-parent.js","src/inputjs/get-center.js","src/inputjs/simple-clone-input-data.js","src/inputjs/get-angle.js","src/inputjs/get-direction.js","src/inputjs/compute-delta-xy.js","src/inputjs/get-velocity.js","src/inputjs/get-scale.js","src/inputjs/get-rotation.js","src/inputjs/compute-interval-input-data.js","src/inputjs/compute-input-data.js","src/inputjs/input-handler.js","src/utils/split-str.js","src/utils/add-event-listeners.js","src/utils/remove-event-listeners.js","src/utils/get-window-for-element.js","src/inputjs/input-constructor.js","src/input/pointerevent.js","src/utils/to-array.js","src/utils/unique-array.js","src/input/touch.js","src/input/mouse.js","src/input/touchmouse.js","src/inputjs/create-input-instance.js","src/manager.js","src/hammer.js","src/input/singletouch.js","src/utils/deprecate.js","src/utils/extend.js","src/utils/merge.js","src/utils/inherit.js","src/main.js"],"sourcesContent":["/**\n * @private\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nexport default function ifUndefined(val1, val2) {\n  return (val1 === undefined) ? val2 : val1;\n}\n","const VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nconst TEST_ELEMENT = document.createElement('div');\n\nconst TYPE_FUNCTION = 'function';\n\nconst { round, abs } = Math;\nconst { now } = Date;\n\nexport {\n    VENDOR_PREFIXES,\n    TEST_ELEMENT,\n    TYPE_FUNCTION,\n    round,\n    abs,\n    now\n};\n","import { VENDOR_PREFIXES } from './utils-consts';\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nexport default function prefixed(obj, property) {\n  let prefix;\n  let prop;\n  let camelProp = property[0].toUpperCase() + property.slice(1);\n\n  let i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = (prefix) ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n","import { NATIVE_TOUCH_ACTION } from './touchaction-Consts';\n\nexport default function getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  let touchMap = {};\n  let cssSupports = window.CSS && window.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((val) => {\n\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n","import prefixed from '../utils/prefixed';\nimport { TEST_ELEMENT } from '../utils/utils-consts';\nimport getTouchActionProps from './get-touchaction-props';\n\nconst PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nconst NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nconst TOUCH_ACTION_AUTO = 'auto';\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nconst TOUCH_ACTION_NONE = 'none';\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nconst TOUCH_ACTION_MAP = getTouchActionProps();\n\nexport {\n    PREFIXED_TOUCH_ACTION,\n    NATIVE_TOUCH_ACTION,\n    TOUCH_ACTION_AUTO,\n    TOUCH_ACTION_COMPUTE,\n    TOUCH_ACTION_MANIPULATION,\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y,\n    TOUCH_ACTION_MAP\n};\n","import prefixed from '../utils/prefixed';\n\nconst MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nconst SUPPORT_TOUCH = ('ontouchstart' in window);\nconst SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nconst SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nconst INPUT_TYPE_TOUCH = 'touch';\nconst INPUT_TYPE_PEN = 'pen';\nconst INPUT_TYPE_MOUSE = 'mouse';\nconst INPUT_TYPE_KINECT = 'kinect';\n\nconst COMPUTE_INTERVAL = 25;\n\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst INPUT_CANCEL = 8;\n\nconst DIRECTION_NONE = 1;\nconst DIRECTION_LEFT = 2;\nconst DIRECTION_RIGHT = 4;\nconst DIRECTION_UP = 8;\nconst DIRECTION_DOWN = 16;\n\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nconst PROPS_XY = ['x', 'y'];\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nexport {\n    MOBILE_REGEX,\n    SUPPORT_ONLY_TOUCH,\n    SUPPORT_POINTER_EVENTS,\n    SUPPORT_TOUCH,\n    INPUT_TYPE_KINECT,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_TOUCH,\n    COMPUTE_INTERVAL,\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    DIRECTION_NONE,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_ALL,\n    PROPS_XY,\n    PROPS_CLIENT_XY\n};\n","const STATE_POSSIBLE = 1;\nconst STATE_BEGAN = 2;\nconst STATE_CHANGED = 4;\nconst STATE_ENDED = 8;\nconst STATE_RECOGNIZED = STATE_ENDED;\nconst STATE_CANCELLED = 16;\nconst STATE_FAILED = 32;\n\nexport {\n    STATE_POSSIBLE,\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_ENDED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_FAILED\n};\n","/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nexport default assign;\n","/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\nexport default function uniqueId() {\n  return _uniqueId++;\n}\n","/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nexport default function each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n","import each from './each';\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nexport default function invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n","/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nexport default function inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n    while (i < src.length) {\n      if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {// do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n","import { TYPE_FUNCTION } from './utils-consts';\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nexport default function boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n","/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nexport default function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  let { manager } = recognizer;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n","import {\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_CHANGED,\n    STATE_BEGAN\n} from './recognizer-consts';\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nexport default function stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n","import {\n    STATE_POSSIBLE,\n    STATE_ENDED,\n    STATE_FAILED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_BEGAN,\n    STATE_CHANGED\n} from './recognizer-consts';\nimport assign from '../utils/assign';\nimport uniqueId from '../utils/unique-id';\nimport ifUndefined from '../utils/if-undefined';\nimport invokeArrayArg from '../utils/invoke-array-arg';\nimport inArray from '../utils/in-array';\nimport boolOrFn from '../utils/bool-or-fn';\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\nimport stateStr from './state-str';\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nexport default class Recognizer {\n  constructor(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let { simultaneous } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let { requireFail } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    let index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n  emit(input) {\n    let self = this;\n    let { state } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    // 'panstart' and 'panmove'\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    }\n\n    // panend and pancancel\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  }\n\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    // it's failing anyway\n    this.state = STATE_FAILED;\n  }\n\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = assign({}, inputData);\n\n    // is is enabled and allow recognizing?\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n  process(inputData) { }\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n  getTouchAction() { }\n\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n  reset() { }\n}\n\nRecognizer.prototype.defaults = {};\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport {\n    INPUT_CANCEL,\n    INPUT_END\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nexport default class AttrRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n  process(input) {\n    let { state } = this;\n    let { eventType } = input;\n\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    let isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  }\n}\n\nAttrRecognizer.prototype.defaults = {\n  /**\n   * @private\n   * @type {Number}\n   * @default 1\n   */\n  pointers: 1\n};\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class RotateRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n}\n\nRotateRecognizer.prototype.defaults = {\n  event: 'rotate',\n  threshold: 0,\n  pointers: 2\n};\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PinchRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n\nPinchRecognizer.prototype.defaults = {\n  event: 'pinch',\n  threshold: 0,\n  pointers: 2\n};\n","import {\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nexport default function directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n","import  AttrRecognizer from './attribute';\nimport {\n    DIRECTION_ALL,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_NONE,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT\n} from '../inputjs/input-consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\nimport { TOUCH_ACTION_PAN_X,TOUCH_ACTION_PAN_Y } from '../touchactionjs/touchaction-Consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PanRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let { options:{ direction } } = this;\n    let actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  directionTest(input) {\n    let { options } = this;\n    let hasMoved = true;\n    let { distance } = input;\n    let { direction } = input;\n    let x = input.deltaX;\n    let y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  }\n\n  attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\n        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n  }\n\n  emit(input) {\n\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    let direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n\nPanRecognizer.prototype.defaults = {\n  event: 'pan',\n  threshold: 10,\n  pointers: 1,\n  direction: DIRECTION_ALL\n};\n","import AttrRecognizer from '../recognizers/attribute';\nimport { abs } from '../utils/utils-consts';\nimport { DIRECTION_HORIZONTAL,DIRECTION_VERTICAL } from '../inputjs/input-consts';\nimport PanRecognizer from './pan';\nimport { INPUT_END } from '../inputjs/input-consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class SwipeRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let { direction } = this.options;\n    let velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return super.attrTest(input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers === this.options.pointers &&\n        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  }\n\n  emit(input) {\n    let direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n\nSwipeRecognizer.prototype.defaults = {\n  event: 'swipe',\n  threshold: 10,\n  velocity: 0.3,\n  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n  pointers: 1\n};\n","/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nexport default function bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n","import bindFn from './bind-fn';\n\n/**\n * @private\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nexport default function setTimeoutContext(fn, timeout, context) {\n  return setTimeout(bindFn(fn, context), timeout);\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nexport default function getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt((x * x) + (y * y));\n}\n","import setTimeoutContext from '../utils/set-timeout-context';\nimport Recognizer from '../recognizerjs/recognizer-constructor';\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\nimport {INPUT_START,INPUT_END } from '../inputjs/input-consts';\nimport {\n    STATE_RECOGNIZED,\n    STATE_BEGAN,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport getDistance from '../inputjs/get-distance';\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nexport default class TapRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let { options } = this;\n\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if ((input.eventType & INPUT_START) && (this.count === 0)) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n      let validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      let tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeoutContext(() => {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.interval, this);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = setTimeoutContext(() => {\n      this.state = STATE_FAILED;\n    }, this.options.interval, this);\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\nTapRecognizer.prototype.defaults = {\n  event: 'tap',\n  pointers: 1,\n  taps: 1,\n  interval: 300, // max time between the multi-tap taps\n  time: 250, // max time of the pointer to be down (like finger on the screen)\n  threshold: 9, // a minimal movement is ok, but keep it low\n  posThreshold: 10 // a multi-tap can be a bit off the initial position\n};\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_RECOGNIZED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport { now } from '../utils/utils-consts';\nimport setTimeoutContext from '../utils/set-timeout-context';\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\nimport {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nexport default class PressRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let { options } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeoutContext(() => {\n        this.state = STATE_RECOGNIZED;\n        this.tryEmit();\n      }, options.time, this);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && (input.eventType & INPUT_END)) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\nPressRecognizer.prototype.defaults = {\n  event: 'press',\n  pointers: 1,\n  time: 251, // minimal time of the pointer to be pressed\n  threshold: 9 // a minimal movement is ok, but keep it low\n};\n","/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nexport default function inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n","import inStr from '../utils/in-str';\nimport {\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y,\n    TOUCH_ACTION_MANIPULATION,\n    TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nexport default function cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n","import {\n    TOUCH_ACTION_COMPUTE,\n    TOUCH_ACTION_MAP,\n    NATIVE_TOUCH_ACTION,\n    PREFIXED_TOUCH_ACTION,\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y\n} from './touchaction-Consts';\nimport {\n    DIRECTION_VERTICAL,\n    DIRECTION_HORIZONTAL\n} from '../inputjs/input-consts';\nimport each from '../utils/each';\nimport boolOrFn from '../utils/bool-or-fn';\nimport inStr from '../utils/in-str';\nimport cleanTouchActions from './clean-touch-actions';\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nexport default class TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  }\n\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n  compute() {\n    let actions = [];\n    each(this.manager.recognizers, (recognizer) => {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  }\n\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n  preventDefaults(input) {\n    let { srcEvent } = input;\n    let direction = input.offsetDirection;\n\n    // if the touch action did prevented once this session\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let { actions } = this;\n    let hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone ||\n        (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n        (hasPanX && direction & DIRECTION_VERTICAL)) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n}\n","/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nexport default function hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n","import { round } from '../utils/utils-consts';\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nexport default function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n","import { now,round } from '../utils/utils-consts';\nimport getCenter from './get-center';\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nexport default function simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nexport default function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n","import { abs } from '../utils/utils-consts';\nimport { DIRECTION_NONE,DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN } from './input-consts';\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nexport default function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n","import { INPUT_START, INPUT_END } from './input-consts';\n\nexport default function computeDeltaXY(session, input) {\n  let { center } = input;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n","/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nexport default function getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n","import { PROPS_CLIENT_XY } from './input-consts';\nimport getDistance from './get-distance';\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nexport default function getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n","import getAngle from './get-angle';\nimport { PROPS_CLIENT_XY } from './input-consts';\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nexport default function getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n","import { INPUT_CANCEL,COMPUTE_INTERVAL } from './input-consts';\nimport { abs } from '../utils/utils-consts';\nimport getVelocity from './get-velocity';\nimport getDirection from './get-direction';\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nexport default function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n","import { now } from '../utils/utils-consts';\nimport { abs } from '../utils/utils-consts';\nimport hasParent from '../utils/has-parent';\nimport simpleCloneInputData from './simple-clone-input-data';\nimport getCenter from './get-center';\nimport getDistance from './get-distance';\nimport getAngle from './get-angle';\nimport getDirection from './get-direction';\nimport computeDeltaXY from './compute-delta-xy';\nimport getVelocity from './get-velocity';\nimport getScale from './get-scale';\nimport getRotation from './get-rotation';\nimport computeIntervalInputData from './compute-interval-input-data';\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nexport default function computeInputData(manager, input) {\n  let { session } = manager;\n  let { pointers } = input;\n  let { length:pointersLength } = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let { firstInput, firstMultiple } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  let center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n  session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n  computeIntervalInputData(session, input);\n\n  // find the correct target\n  let target = manager.element;\n  if (hasParent(input.srcEvent.target, target)) {\n    target = input.srcEvent.target;\n  }\n  input.target = target;\n}\n","import { INPUT_START,INPUT_END,INPUT_CANCEL } from './input-consts';\nimport computeInputData from './compute-input-data';\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nexport default function inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n  let isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n","/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nexport default function splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function addEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.addEventListener(type, handler, false);\n  });\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function removeEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n","/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nexport default function getWindowForElement(element) {\n  let doc = element.ownerDocument || element;\n  return (doc.defaultView || doc.parentWindow || window);\n}\n","import boolOrFn from '../utils/bool-or-fn';\nimport addEventListeners from '../utils/add-event-listeners';\nimport removeEventListeners from '../utils/remove-event-listeners';\nimport getWindowForElement from '../utils/get-window-for-element';\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nexport default class Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n  handler() { }\n\n  /**\n   * @private\n   * bind the events\n   */\n  init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * @private\n   * unbind the events\n   */\n  destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_MOVE,\n    INPUT_TYPE_TOUCH,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_KINECT\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport inArray from '../utils/in-array';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nconst IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\nexport default class PointerEventInput extends Input {\n  constructor() {\n    super(...arguments);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    this.init();\n    this.store = (this.manager.session.pointerEvents = []);\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let { store } = this;\n    let removePointer = false;\n\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n    let isTouch = (pointerType === INPUT_TYPE_TOUCH);\n\n    // get index of the event in the store\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    // start and mouse must be down\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n","/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nexport default function toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n","import inArray from './in-array';\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nexport default function uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport hasParent from '../utils/has-parent';\nimport uniqueArray from '../utils/unique-array';\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nexport default class TouchInput extends Input {\n\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    TouchInput.prototype.targetIds = {};\n    super(...arguments);\n\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    this.init();\n  }\n\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds } = this;\n\n  // when there is only one touch, the process can be simplified\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = toArray(ev.changedTouches);\n  let changedTargetTouches = [];\n  let { target } = this;\n\n  // get target touches from touches\n  targetTouches = allTouches.filter((touch) => {\n    return hasParent(touch.target, target);\n  });\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n      // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n      uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n      changedTargetTouches\n  ];\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_TYPE_MOUSE\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\n\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nconst MOUSE_ELEMENT_EVENTS = 'mousedown';\nconst MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\nexport default class MouseInput extends Input {\n  constructor() {\n    super(...arguments);\n\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n    this.init();\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n\n    // on start we want to have the left mouse button down\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  }\n}\n","import Input from '../inputjs/input-constructor';\nimport bindFn from '../utils/bind-fn';\nimport  TouchInput  from './touch';\nimport  MouseInput  from './mouse';\nimport {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH,\n    INPUT_TYPE_MOUSE\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nconst DEDUP_TIMEOUT = 2500;\nconst DEDUP_DISTANCE = 25;\n\nexport default class TouchMouseInput extends Input {\n  constructor() {\n    super(...arguments);\n    this.init();\n    let handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  /**\n   * @private\n   * handle mouse and touch events\n   * @param {Hammer} manager\n   * @param {String} inputEvent\n   * @param {Object} inputData\n   */\n  handler(manager, inputEvent, inputData) {\n    let isTouch = (inputData.pointerType === INPUT_TYPE_TOUCH);\n    let isMouse = (inputData.pointerType === INPUT_TYPE_MOUSE);\n\n    if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n      return;\n    }\n\n    // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n    if (isTouch) {\n      recordTouches.call(this, inputEvent, inputData);\n    } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n      return;\n    }\n\n    this.callback(manager, inputEvent, inputData);\n  }\n\n  /**\n   * @private\n   * remove the event listeners\n   */\n  destroy() {\n    this.touch.destroy();\n    this.mouse.destroy();\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction setLastTouch(eventData) {\n  let { changedPointers:[touch] } = eventData;\n  if (touch.identifier === this.primaryTouch) {\n    let lastTouch = { x: touch.clientX, y: touch.clientY };\n    this.lastTouches.push(lastTouch);\n    let lts = this.lastTouches;\n    let removeLastTouch = function() {\n      let i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  let x = eventData.srcEvent.clientX;\n  let y = eventData.srcEvent.clientY;\n  for (let i = 0; i < this.lastTouches.length; i++) {\n    let t = this.lastTouches[i];\n    let dx = Math.abs(x - t.x);\n    let dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { SUPPORT_POINTER_EVENTS,SUPPORT_ONLY_TOUCH,SUPPORT_TOUCH } from './input-consts';\nimport inputHandler from './input-handler';\nimport PointerEventInput from '../input/pointerevent';\nimport TouchInput from '../input/touch';\nimport MouseInput from '../input/mouse';\nimport TouchMouseInput from '../input/touchmouse';\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nexport default function createInputInstance(manager) {\n  let Type;\n  // let inputClass = manager.options.inputClass;\n  let { options:{ inputClass } } = manager;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new (Type)(manager, inputHandler);\n}\n","import assign from './utils/assign';\nimport  Hammer  from './hammer';\nimport TouchAction from './touchactionjs/touchaction-constructor';\nimport createInputInstance from './inputjs/create-input-instance';\nimport each from './utils/each';\nimport inArray from './utils/in-array';\nimport invokeArrayArg from './utils/invoke-array-arg';\nimport splitStr from './utils/split-str';\nimport prefixed from './utils/prefixed';\nimport Recognizer from './recognizerjs/recognizer-constructor';\nimport {\n    STATE_BEGAN,\n    STATE_ENDED,\n    STATE_CHANGED,\n    STATE_RECOGNIZED\n} from './recognizerjs/recognizer-consts';\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Manager {\n  constructor(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, (item) => {\n      let recognizer = this.add(new (item[0])(item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    let { session } = this;\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    this.touchAction.preventDefaults(inputData);\n\n    let recognizer;\n    let { recognizers } = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let { curRecognizer } = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (// 1\n              !curRecognizer || recognizer === curRecognizer || // 2\n              recognizer.canRecognizeWith(curRecognizer))) { // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n  get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    let { recognizers } = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n  add(recognizer) {\n    if (invokeArrayArg(recognizer, 'add', this)) {\n      return this;\n    }\n\n    // remove existing\n    let existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n  remove(recognizer) {\n    if (invokeArrayArg(recognizer, 'remove', this)) {\n      return this;\n    }\n\n    recognizer = this.get(recognizer);\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      let { recognizers } = this;\n      let index = inArray(recognizers, recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n  on(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n    if (handler === undefined) {\n      return;\n    }\n\n    let { handlers } = this;\n    each(splitStr(events), (event) => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n  off(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n\n    let { handlers } = this;\n    each(splitStr(events), (event) => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n  emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    }\n\n    // no handlers, so skip it all\n    let handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n    data.preventDefault = function() {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.element && toggleCssProps(this, false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n}\n\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n  let { element } = manager;\n  if (!element.style) {\n    return;\n  }\n  let prop;\n  each(manager.options.cssProps, (value, name) => {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || '';\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n  let gestureEvent = document.createEvent('Event');\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n","import ifUndefined from './utils/if-undefined';\nimport { TOUCH_ACTION_COMPUTE } from './touchactionjs/touchaction-Consts';\nimport { DIRECTION_HORIZONTAL } from './inputjs/input-consts';\nimport RotateRecognizer from './recognizers/rotate';\nimport PinchRecognizer from './recognizers/pinch';\nimport SwipeRecognizer from './recognizers/swipe';\nimport PanRecognizer from './recognizers/pan';\nimport TapRecognizer from './recognizers/tap';\nimport PressRecognizer from './recognizers/press';\nimport  Manager  from './manager';\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Hammer {\n  constructor(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n}\n\n/**\n * @private\n * @const {string}\n */\nHammer.VERSION = '{{PKG_VERSION}}';\n\n/**\n * @private\n * default settings\n * @namespace\n */\nHammer.defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [\n      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, { enable: false }],\n      [PinchRecognizer, { enable: false }, ['rotate']],\n      [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n      [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n      [TapRecognizer],\n      [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n      [PressRecognizer]\n  ],\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: 'none',\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: 'none',\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: 'none',\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: 'none',\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: 'none',\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport uniqueArray from '../utils/unique-array';\n\nconst SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nconst SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\nexport default class SingleTouchInput extends Input {\n  constructor() {\n    super(...arguments);\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n    this.init();\n  }\n\n  handler(ev) {\n    let type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n    // should we handle the touch events?\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    let touches = normalizeSingleTouches.call(this, ev, type);\n\n    // when done, reset the started state\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n  let all = toArray(ev.touches);\n  let changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n","/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nexport default function deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function() {\n    let e = new Error('get-stack-trace');\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n        .replace(/^\\s+at\\s+/gm, '')\n        .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n    let log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n","import deprecate from './deprecate';\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = deprecate((dest, src, merge) => {\n  let keys = Object.keys(src);\n  let i = 0;\n  while (i < keys.length) {\n    if (!merge || (merge && dest[keys[i]] === undefined)) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\nexport default extend;\n","import deprecate from './deprecate';\nimport extend from './extend';\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = deprecate((dest, src) => {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\nexport default merge;\n","import assign from './assign';\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nexport default function inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign(childP, properties);\n  }\n}\n","import Hammer from './hammer';\nimport assign from './utils/assign';\nimport {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL\n} from './inputjs/input-consts';\nimport {\n    STATE_POSSIBLE,\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_ENDED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_FAILED\n} from './recognizerjs/recognizer-consts';\nimport {\n    DIRECTION_NONE,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_ALL\n} from './inputjs/input-consts';\n\nimport Manager from './manager';\nimport Input from './inputjs/input-constructor';\nimport TouchAction from './touchactionjs/touchaction-constructor';\nimport TouchInput from './input/touch';\nimport MouseInput from './input/mouse';\nimport PointerEventInput from './input/pointerevent';\nimport SingleTouchInput from './input/singletouch';\nimport TouchMouseInput from './input/touchmouse';\n\nimport Recognizer from  './recognizerjs/recognizer-constructor';\nimport AttrRecognizer from './recognizers/attribute';\nimport TapRecognizer from './recognizers/tap';\nimport PanRecognizer from './recognizers/pan';\nimport SwipeRecognizer from './recognizers/swipe';\nimport PinchRecognizer from './recognizers/pinch';\nimport RotateRecognizer from './recognizers/rotate';\nimport PressRecognizer from './recognizers/press';\n\nimport addEventListeners from './utils/add-event-listeners';\nimport removeEventListeners from './utils/remove-event-listeners';\nimport each from './utils/each';\nimport merge from './utils/merge';\nimport extend from './utils/extend';\nimport inherit from './utils/inherit';\nimport bindFn from './utils/bind-fn';\nimport prefixed from './utils/prefixed';\nimport toArray from'./utils/to-array';\nimport uniqueArray from'./utils/unique-array';\nimport splitStr from'./utils/split-str';\nimport inArray from'./utils/in-array';\nimport boolOrFn from'./utils/bool-or-fn';\nimport hasParent from'./utils/has-parent';\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nassign(Hammer, {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n\n  Manager,\n  Input,\n  TouchAction,\n\n  TouchInput,\n  MouseInput,\n  PointerEventInput,\n  TouchMouseInput,\n  SingleTouchInput,\n\n  Recognizer,\n  AttrRecognizer,\n  Tap: TapRecognizer,\n  Pan: PanRecognizer,\n  Swipe: SwipeRecognizer,\n  Pinch: PinchRecognizer,\n  Rotate: RotateRecognizer,\n  Press: PressRecognizer,\n\n  on: addEventListeners,\n  off: removeEventListeners,\n  each,\n  merge,\n  extend,\n  assign,\n  inherit,\n  bindFn,\n  prefixed,\n  toArray,\n  inArray,\n  uniqueArray,\n  splitStr,\n  boolOrFn,\n  hasParent,\n  addEventListeners,\n  removeEventListeners\n});\n\nlet freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\n/* jshint ignore:start */\nif (typeof define === 'function' && define.amd) {\n  define(() => {\n    return Hammer;\n  });\n} else if (typeof module !== 'undefined' && module.exports) {\n  module.exports = Hammer;\n} else {\n  window[exportName] = Hammer;\n}\n/* jshint ignore:end */\n"],"names":["ifUndefined","val1","val2","undefined","VENDOR_PREFIXES","TEST_ELEMENT","document","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","prefixed","obj","property","prefix","prop","camelProp","toUpperCase","slice","i","length","getTouchActionProps","NATIVE_TOUCH_ACTION","touchMap","cssSupports","window","CSS","supports","forEach","val","PREFIXED_TOUCH_ACTION","style","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","MOBILE_REGEX","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","assign","Object","target","TypeError","output","index","arguments","source","nextKey","hasOwnProperty","_uniqueId","uniqueId","each","iterator","context","call","invokeArrayArg","arg","fn","Array","isArray","inArray","src","find","findByKey","indexOf","boolOrFn","args","apply","getRecognizerByNameIfManager","otherRecognizer","recognizer","manager","get","stateStr","state","Recognizer","options","defaults","id","enable","simultaneous","requireFail","touchAction","update","recognizeWith","push","requireFailure","splice","input","self","emit","event","additionalEvent","canEmit","inputData","inputDataClone","reset","process","tryEmit","prototype","AttrRecognizer","optionPointers","pointers","eventType","isRecognized","isValid","attrTest","RotateRecognizer","babelHelpers.get","rotation","threshold","PinchRecognizer","scale","inOut","directionStr","direction","PanRecognizer","pX","pY","actions","hasMoved","distance","x","deltaX","y","deltaY","directionTest","SwipeRecognizer","getTouchAction","velocity","overallVelocity","overallVelocityX","overallVelocityY","offsetDirection","maxPointers","bindFn","boundFn","setTimeoutContext","timeout","setTimeout","getDistance","p1","p2","props","sqrt","TapRecognizer","pTime","pCenter","_timer","_input","count","validPointers","validMovement","validTouchTime","deltaTime","time","failTimeout","validInterval","timeStamp","interval","validMultiTap","center","posThreshold","tapCount","taps","hasRequireFailures","PressRecognizer","validTime","inStr","str","cleanTouchActions","hasPanX","hasPanY","TouchAction","value","set","compute","element","toLowerCase","trim","recognizers","concat","join","srcEvent","session","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","hasParent","node","parent","parentNode","getCenter","pointersLength","clientX","clientY","simpleCloneInputData","getAngle","atan2","PI","getDirection","computeDeltaXY","offset","offsetDelta","prevDelta","prevInput","getVelocity","getScale","start","end","getRotation","computeIntervalInputData","last","lastInterval","velocityX","velocityY","v","computeInputData","firstInput","firstMultiple","offsetCenter","angle","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","recognize","splitStr","split","addEventListeners","types","handler","type","addEventListener","removeEventListeners","removeEventListener","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","callback","inputTarget","domHandler","ev","evEl","evTarget","evWin","POINTER_INPUT_MAP","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","init","store","pointerEvents","removePointer","eventTypeNormalized","replace","pointerType","isTouch","storeIndex","pointerId","button","toArray","uniqueArray","key","sort","results","values","a","b","TOUCH_INPUT_MAP","TOUCH_TARGET_EVENTS","TouchInput","targetIds","touches","getTouches","allTouches","identifier","targetTouches","changedTouches","changedTargetTouches","filter","touch","MOUSE_INPUT_MAP","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","pressed","which","DEDUP_TIMEOUT","DEDUP_DISTANCE","TouchMouseInput","mouse","primaryTouch","lastTouches","inputEvent","isMouse","sourceCapabilities","firesTouchEvents","isSyntheticEvent","destroy","recordTouches","eventData","setLastTouch","lastTouch","lts","removeLastTouch","t","dx","dy","createInputInstance","Type","inputClass","STOP","FORCED_STOP","Manager","Hammer","handlers","oldCssProps","item","add","force","stopped","preventDefaults","curRecognizer","canRecognizeWith","existing","remove","events","data","domEvents","toggleCssProps","cssProps","name","triggerDomEvent","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","preset","VERSION","SINGLE_TOUCH_INPUT_MAP","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","normalizeSingleTouches","all","changed","deprecate","method","message","deprecationMessage","e","Error","stack","log","console","warn","extend","dest","merge","keys","inherit","child","base","properties","baseP","childP","create","constructor","_super","freeGlobal","define","amd","module","exports","exportName"],"mappings":"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"}